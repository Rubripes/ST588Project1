---
title: | 
     | ST588Homework4
     | Matt Bray
     | Tyler Hunt
format: html
code-overflow: wrap
editor: visual
---

# Install tidy Census/Load library for API Package

## Notes for user: you should load the packages below if not loaded on your machine, and install the libraries as specified below.

```{r}
library("tidyverse")
library("censusapi")
library("tidycensus")
library("jsonlite")
library("dplyr")
library("lubridate")
```

# Check names *can be removed from final project, or kept to help user find columns of interest*

```{r}
nameList <- listCensusMetadata(
  "acs/acs1/pums",
  vintage = 2022,
  type = "variables",
  include_values = FALSE
)
nameLista <- as_tibble(nameList)
head(nameLista) 
```

# Save Census Key

# User should define variable aKey with key generated from Census API key generator: https://api.census.gov/data/key_signup.html

## See help documentation for tidycensus package here: https://walker-data.com/tidycensus/reference/census_api_key.html

```{r}
#census_api_key(key="b8bf07f35eb3e0d8ab1f95f20172b2ff62eb4514", overwrite = FALSE, install = TRUE)
```

# Get data from Census API for State:17

```{r}
censusData <- getCensus(name="acs/acs1/pums", vintage = 2022, key = Sys.getenv("CENSUS_API_KEY") , vars = c("PWGTP", "AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), regionin="state:17")

#censusTbl<-as_tibble(censusData)
```

##Visualize Structure of censusData *can be removed from final project*

```{r}
head(censusTbl)
length(censusTbl$PWGTP)
```

## We are testing that an example API call to the Census API returns a result. We see the status 200 meaning our call has worked!

```{r}
censusApiTest <- httr::GET(paste('https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24'))

censusApiTest
```
## Create a function to transform the HTTP/API request to a tibble
```{r}
rawToTibble <- function(rawData){
  jsonData <- fromJSON(rawToChar(rawData$content))
  ## Extract column names
  colNames <- jsonData[1,]
  
  # Remove the first row from the data 
  jsonData <- jsonData[-1,]
  
  tibbleData <- as_tibble(jsonData)
  colnames(tibbleData) <- colNames
  return(tibbleData)
}

rawToTibble(censusApiTest)
```

## Create a function to help with querying the API
```{r}
checkVarsValid <- function(vars,validVars){
    if (!all(vars %in% validVars)) {
    stop("Invalid variables: ", paste(vars[!vars %in% validVars], collapse = ", "))
  }
}

varsLkpTibble <- function(year,varName,lkpVal="lkpVal"){
  rawData <- httr::GET(url=paste0('https://api.census.gov/data/',year,'/acs/acs1/pums/variables/',varName,'.json'))
  jsonData <- fromJSON(rawToChar(rawData$content))
  tibbleData <- as_tibble(jsonData$values$item)
  tibbleData <- tibbleData %>%
    pivot_longer(cols=names(tibbleData),
                 names_to = varName,
                 values_to = lkpVal
                 )
  return(tibbleData)
}

midTimeFunc <- function(startTime,endTime){
  midAddlSecs <- as.numeric(difftime(endTime,startTime,units="secs"))/2
  midTotalSecs <- as.numeric(startTime) + midAddlSecs
  midhours <- floor(midTotalSecs/(60*60))
  midminutes <- floor((midTotalSecs-(60*60*midhours))/60)
  midseconds <- floor((midTotalSecs-(60*60*midhours)-60*midminutes)/60)
  timeString <- paste(midhours,midminutes,midseconds,sep=":")
  hmsTime <- hms::parse_hms(timeString)
  return(timeString)
}

lkpToMiddleTime <- function(tibble,year=2022,timeVar){
  apiData <- varsLkpTibble(year=year,varName = timeVar,lkpVal = "TIME_INTERVAL")
  intervalTibble <- inner_join(tibble,apiData)
  returnData <- intervalTibble %>%
    select(-c(timeVar)) %>%
    mutate(TIME_INTERVAL = ifelse(TIME_INTERVAL == "N/A (not a worker; worker who worked from home)", NA, TIME_INTERVAL))
  names(returnData) <- c(names(returnData)[1:(length(names(returnData))-1)],timeVar)
  returnData <- returnData %>%
    separate_wider_delim(timeVar,delim = " to ",names=c('StartTime','EndTime')) %>%
    mutate(StartTime = parse_time(gsub("\\.", "", StartTime),format = "%I:%M %p"),
           EndTime = parse_time(gsub("\\.", "", EndTime),format = "%I:%M %p"),
           MidTime = ifelse(!is.na(StartTime), midTimeFunc(StartTime,EndTime),NA)
           )
  returnData[[timeVar]] <- hms::as_hms(returnData$MidTime)
  returnData <- returnData %>%
    select(-c('StartTime','EndTime','MidTime'))
  return(returnData)
}

factorLkp <- function(tibbleData,year,catVar){
  apiData <- varsLkpTibble(year=year,varName = catVar)
  x <- tibbleData[[catVar]]
  levels <- sort(unique(x))
  apiData <- apiData %>%
    filter(get(catVar) %in% levels) %>%
    arrange(get(catVar))
  labels <- apiData$lkpVal
  newVec <- factor(x=x,levels=levels,labels = labels)
  tibbleData[[catVar]] <- newVec
  return(tibbleData)
}
```

```{r}
factorTest <- factorLkp(tibbleData=state17,year=2022,catVar="FER")
factorTest
```



```{r}
retrieveCensus <- function(year=2022,numericVars=c("AGEP","PWGTP"),catVars=c("SEX"),geographyLevel =c("All"),geographySpec = NULL){
  # Check if year is a single value AND the value passed is between 2010 and 2022
  
  if (length(year)!=1){
    stop("A single year must be passed")
  }
  
  if (year < 2010 | year > 2022){
    stop("The year passed must be between 2010 & 2022")
  }
  
  # Check if values passed in the numericVars (catVars) are within the numericOptions (catOptions) vector(s)
  
  numericReq <- "PWGTP"
  
  numericOptions <- c("AGEP","GASP","GRPIP","JWMNP","PWGTP")
  timeOptions <- c("JWAP","JWDP")
  
  numericTimeOptions <- c(numericOptions,timeOptions)
  
  checkVarsValid(var=numericVars,validVars = numericTimeOptions)
  
  catOptions <- c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX")
  
  checkVarsValid(vars=catVars, validVars = catOptions)
  
  geographyOptions <- c("All","Region","Division","State")
  
  checkVarsValid(vars=geographyLevel, validVars = geographyOptions)
  
  ## If PWGTP not in the numericVars parameter, add it
  
  if (numericReq %in% numericVars) {
    numericVars <- numericVars
  } else {
    numericVars <- c(numericVars,numericReq)
  }
  
  ## Check to make sure the number of numeric variables that will be returned is NOT < 2. The number of categorical variables should not be < 1
  
  if (length(numericVars) < 2) {
    stop("One numeric variable other than ", paste(numericReq)," must be given in the numericVars parameter")
  }
  
  if (length(catVars) < 1) {
    stop("One categorical variable must be given to be returned")
  }
  
 ## If all variables are of valid length and valid values, paste them together to be passed in the API call
  
  regioninPrefix <- switch(
    geographyLevel,
    All = "",
    Division = "division",
    Region = "region",
    State = "state"
  )
  regioninSuffix <- ifelse(is.null(geographySpec),"*",geographySpec)
  
  regioninString <- if(regioninPrefix!=""){paste0('&for=',regioninPrefix,":",regioninSuffix)}
  
  allVarsReq <- c(numericVars,catVars)
  varString <- NULL
  
  for (value in allVarsReq){
    varString <- paste0(varString,value,if(value != allVarsReq[length(allVarsReq)]){","})
  }
  
  apiURL <- paste0('https://api.census.gov/data/',year,'/acs/acs1/pums?get=',varString,regioninString)
  
  rawData <- httr::GET(apiURL)
  
  data <- rawToTibble(rawData)
  
  ## Change data types to be appropriate
  
  #data[numericVars[numericVars %in% timeOptions]] <- lapply(data[numericVars[numericVars %in% timeOptions]],as.POSIXct,format = "%Y-%m-%d %H:%M:%S")
  
  
  for (value in intersect(numericVars,timeOptions)){
    data <- lkpToMiddleTime(data,year=year,timeVar = value)
  }
  
  data[numericVars[numericVars %in% numericOptions]] <- lapply(data[numericVars[numericVars %in% numericOptions]],as.numeric)
  
  for (value in catVars){
    data <- factorLkp(data,year=year,catVar = value)
  }
  
  return(data)
}
```

```{r}
state17 <- retrieveCensus(year=2022,numericVars=c("AGEP","PWGTP","JWDP"),catVars=c("FER","SEX"),geographyLevel = "State",geographySpec = 17)

state17
```


## Function to pass multiple years and retrieve data

```{r}
retrieveMultiYearCensus <- function(years=c(2022),numericVars=c("AGEP","PWGTP"),catVars=c("SEX"),geographyLevel =c("All"),geographySpec = NULL) {
  combinedTibble <- retrieveCensus(year=years[1],numericVars=numericVars,catVars=catVars,geographyLevel=geographyLevel,geographySpec = geographySpec)
  combinedTibble$year <- years[1]
  for (i in 2:length(years)) {
    yearTibble <- retrieveCensus(year=years[i],numericVars=numericVars,catVars=catVars,geographyLevel=geographyLevel,geographySpec = geographySpec)
    yearTibble$year <- years[i]
    combinedTibble <- dplyr::union(combinedTibble,yearTibble)
  }
  return(combinedTibble)
}
```

## Testing multi-year function
```{r}
state17MultiYear <- retrieveMultiYearCensus(years=c(2021,2022),geographyLevel = "State",geographySpec = 17)

state17MultiYear
```

# Writing a Generic Function for Summarizing

### test "retrieveCensus" function

```{r}
censusData<-retrieveCensus(year=2022, numericVars=c("AGEP", "GASP", "PWGTP", "JWAP", "JWDP"), catVars = c("SEX", "HHL"),geographyLevel = "State",geographySpec = 17)
```

### Check "retrieveCensus" function output object structure

```{r}
names(censusData)
length(names(censusData))
str(censusData)
head(censusData)
censusData
```

# Create custom summary function

```{r}
#numVars <- c("AGEP","GASP","GRPIP","JWMNP","PWGTP")
#catVars <- c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX")
numericData <- censusData|>
  select(where(is.numeric) & -"PWGTP")
#numericData  
charData <- censusData|>
  select(where(is.factor))
#charData


#create loop to mean each variable from numCensus and place in list with name
splMean <- list()
for(i in 1:length(numericData)){
  splMean[[i]] <- as.numeric((sum(numericData[[i]] %*% censusData$PWGTP)/sum(censusData$PWGTP)))
  names(splMean)[i]<-paste(names(numericData[i]))
}

#create loop to calculate sample SD from numCensus and place in list with name
splSD <- list()
for(i in 1:length(numericData)){
  splSD[[i]] <- (sqrt(sum(numericData[[i]]^2 %*% censusData$PWGTP)/sum(censusData$PWGTP)-splMean[[i]]^2))
  names(splSD)[i]<-paste(names(numericData[i]))
}

splMeanTbl<-as_tibble(splMean)
splSDTbl<-as_tibble(splSD)


#Create loop to generate counts for each categorical variable
catSummary <- list()
for(i in 1:length(charData)){
  catSummary[[i]]<- charData[i] |>
    group_by(charData[i]) |>
    summarize(n=n())
    names(splCount)[i]<-paste("count", names(charData[i]), sep="_")
}

numSumRowNames <- as_tibble(c("splMean", "splSD"))
numericSum <- tibble()
numericSum <- bind_rows(splMeanTbl,splSDTbl)
numericSumNamed <- bind_cols(numSumRowNames,numericSum)


numericSumNamed
catSummary


##############################################################
#Possibly useful code below, may not be necessary

##Create a list of variable strings to loop through function

#create list of splMean for each returned numeric variable
numVarString<-character(nrow(numVarsTblShort))
 for(i in 1:nrow(numVarsTblShort)) {
   numVarString[i]<-as_vector(paste("censusData",numVarsTblShort[i,], sep="$"))
 }

splMean<-sum(numCensus[[1]] %*% censusData$PWGTP)/sum(censusData$PWGTP)
splMean

splSD<-sqrt(sum(numCensus$AGEP^2 %*% censusData$PWGTP)/sum(censusData$PWGTP)-splMean[[1]]^2)
splSD

numVarString<-character(nrow(numVarsTblShort))

 for(i in 1:nrow(numVarsTblShort)) {
   numVarString[i]<-as_vector(paste("censusData",numVarsTblShort[i,], sep="$"))
}
#numVarString

splMean<-length(as_vector(numVarString))
for(i in 1:length(as_vector(dataNumVarsTbl))){
  
}

catVarString<-character(nrow(catVarsTblShort))
 for(i in 1:nrow(catVarsTblShort)) {
   catVarString[i]<-as_vector(paste(catVarsTblShort[i,],"[i]", sep="$"))
}


length(as_vector(numVarsTblShort))
length(numVarString)
catVarString
nrow(numVarsTblShort)
names(dataCatVarsTbl)

lengths(dataCatVarsTbl$value)

dataCatVarsTbl$value

dataCatVarsTbl
dataNumVarsTbl
catVarsTblShort
nrow(numVarsTblShort)

namesCensusData
dataCatVars
dataNumVars
rm(numVarString)
```

### Test Summary Function

```{r}
summary<-summaryCensus(tbl=censusData)
summary
```