---
title: | 
     | ST588Homework4
     | Matt Bray
     | Tyler Hunt
format: html
code-overflow: wrap
editor: visual
---

# Install tidy Census/Load library for API Package

## Notes for user: you should load the packages below if not loaded on your machine, and install the libraries as specified below.

```{r}
library("tidyverse")
library("censusapi")
library("tidycensus")
library("jsonlite")
library("dplyr")
library("lubridate")
```

# Check names *can be removed from final project, or kept to help user find columns of interest*

```{r}
#nameList <- listCensusMetadata(
#  "acs/acs1/pums",
#  vintage = 2022,
#  type = "variables",
#  include_values = FALSE
#)
#nameLista <- as_tibble(nameList)
#head(nameLista) 
```

# Save Census Key

# User should define variable aKey with key generated from Census API key generator: https://api.census.gov/data/key_signup.html

## See help documentation for tidycensus package here: https://walker-data.com/tidycensus/reference/census_api_key.html

```{r}
#census_api_key(key="b8bf07f35eb3e0d8ab1f95f20172b2ff62eb4514", overwrite = FALSE, install = TRUE)
```

# Get data from Census API for State:17

```{r}
#censusData <- getCensus(name="acs/acs1/pums", vintage = 2022, key = Sys.getenv("CENSUS_API_KEY") , vars = c("PWGTP", "AGEP", "GASP", "GRPIP", "JWAP", "JWDP", "JWMNP"), regionin="state:17")

#censusTbl<-as_tibble(censusData)
```

##Visualize Structure of censusData *can be removed from final project*

```{r}
#head(censusTbl)
#length(censusTbl$PWGTP)
```

## We are testing that an example API call to the Census API returns a result. We see the status 200 meaning our call has worked!

```{r}
#censusApiTest <- httr::GET(paste('https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24'))

#censusApiTest
```

## Create a function to transform the HTTP/API request to a tibble

```{r}
rawToTibble <- function(rawData){
  jsonData <- fromJSON(rawToChar(rawData$content))
  ## Extract column names
  colNames <- jsonData[1,]
  
  # Remove the first row from the data 
  jsonData <- jsonData[-1,]
  
  tibbleData <- as_tibble(jsonData)
  colnames(tibbleData) <- colNames
  return(tibbleData)
}

#rawToTibble(censusApiTest)
```

## Create a function to help with querying the API

```{r}
checkVarsValid <- function(vars,validVars){
    if (!all(vars %in% validVars)) {
    stop("Invalid variables: ", paste(vars[!vars %in% validVars], collapse = ", "))
  }
}

varsLkpTibble <- function(year,varName,lkpVal="lkpVal"){
  rawData <- httr::GET(url=paste0('https://api.census.gov/data/',year,'/acs/acs1/pums/variables/',varName,'.json'))
  jsonData <- fromJSON(rawToChar(rawData$content))
  tibbleData <- as_tibble(jsonData$values$item)
  tibbleData <- tibbleData %>%
    pivot_longer(cols=names(tibbleData),
                 names_to = varName,
                 values_to = lkpVal
                 )
  return(tibbleData)
}

midTimeFunc <- function(startTime,endTime){
  midAddlSecs <- as.numeric(difftime(endTime,startTime,units="secs"))/2
  midTotalSecs <- as.numeric(startTime) + midAddlSecs
  midhours <- floor(midTotalSecs/(60*60))
  midminutes <- floor((midTotalSecs-(60*60*midhours))/60)
  midseconds <- floor((midTotalSecs-(60*60*midhours)-60*midminutes)/60)
  timeString <- paste(midhours,midminutes,midseconds,sep=":")
  hmsTime <- hms::parse_hms(timeString)
  return(timeString)
}

lkpToMiddleTime <- function(tibble,year=2022,timeVar){
  apiData <- varsLkpTibble(year=year,varName = timeVar,lkpVal = "TIME_INTERVAL")
  intervalTibble <- inner_join(tibble,apiData)
  returnData <- intervalTibble %>%
    select(-c(timeVar)) %>%
    mutate(TIME_INTERVAL = ifelse(TIME_INTERVAL == "N/A (not a worker; worker who worked from home)", NA, TIME_INTERVAL))
  names(returnData) <- c(names(returnData)[1:(length(names(returnData))-1)],timeVar)
  returnData <- returnData %>%
    separate_wider_delim(timeVar,delim = " to ",names=c('StartTime','EndTime')) %>%
    mutate(StartTime = parse_time(gsub("\\.", "", StartTime),format = "%I:%M %p"),
           EndTime = parse_time(gsub("\\.", "", EndTime),format = "%I:%M %p"),
           MidTime = ifelse(!is.na(StartTime), midTimeFunc(StartTime,EndTime),NA)
           )
  returnData[[timeVar]] <- hms::as_hms(returnData$MidTime)
  returnData <- returnData %>%
    select(-c('StartTime','EndTime','MidTime'))
  return(returnData)
}

factorLkp <- function(tibbleData,year,catVar){
  apiData <- varsLkpTibble(year=year,varName = catVar)
  x <- tibbleData[[catVar]]
  levels <- sort(unique(x))
  apiData <- apiData %>%
    filter(get(catVar) %in% levels) %>%
    arrange(get(catVar))
  labels <- apiData$lkpVal
  newVec <- factor(x=x,levels=levels,labels = labels)
  tibbleData[[catVar]] <- newVec
  return(tibbleData)
}
```

```{r}
#factorTest <- factorLkp(tibbleData=state17,year=2022,catVar="FER")
#factorTest
```

```{r}
retrieveCensus <- function(year=2022,numericVars=c("AGEP","PWGTP"),catVars=c("SEX"),geographyLevel =c("All"),geographySpec = NULL){
  # Check if year is a single value AND the value passed is between 2010 and 2022
  
  if (length(year)!=1){
    stop("A single year must be passed")
  }
  
  if (year < 2010 | year > 2022){
    stop("The year passed must be between 2010 & 2022")
  }
  
  # Check if values passed in the numericVars (catVars) are within the numericOptions (catOptions) vector(s)
  
  numericReq <- "PWGTP"
  
  numericOptions <- c("AGEP","GASP","GRPIP","JWMNP","PWGTP")
  timeOptions <- c("JWAP","JWDP")
  
  numericTimeOptions <- c(numericOptions,timeOptions)
  
  checkVarsValid(var=numericVars,validVars = numericTimeOptions)
  
  catOptions <- c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX")
  
  checkVarsValid(vars=catVars, validVars = catOptions)
  
  geographyOptions <- c("All","Region","Division","State")
  
  checkVarsValid(vars=geographyLevel, validVars = geographyOptions)
  
  ## If PWGTP not in the numericVars parameter, add it
  
  if (numericReq %in% numericVars) {
    numericVars <- numericVars
  } else {
    numericVars <- c(numericVars,numericReq)
  }
  
  ## Check to make sure the number of numeric variables that will be returned is NOT < 2. The number of categorical variables should not be < 1
  
  if (length(numericVars) < 2) {
    stop("One numeric variable other than ", paste(numericReq)," must be given in the numericVars parameter")
  }
  
  if (length(catVars) < 1) {
    stop("One categorical variable must be given to be returned")
  }
  
 ## If all variables are of valid length and valid values, paste them together to be passed in the API call
  
  regioninPrefix <- switch(
    geographyLevel,
    All = "",
    Division = "division",
    Region = "region",
    State = "state"
  )
  regioninSuffix <- ifelse(is.null(geographySpec),"*",geographySpec)
  
  regioninString <- if(regioninPrefix!=""){paste0('&for=',regioninPrefix,":",regioninSuffix)}
  
  allVarsReq <- c(numericVars,catVars)
  varString <- NULL
  
  for (value in allVarsReq){
    varString <- paste0(varString,value,if(value != allVarsReq[length(allVarsReq)]){","})
  }
  
  apiURL <- paste0('https://api.census.gov/data/',year,'/acs/acs1/pums?get=',varString,regioninString)
  
  rawData <- httr::GET(apiURL)
  
  data <- rawToTibble(rawData)
  
  ## Change data types to be appropriate
  
  #data[numericVars[numericVars %in% timeOptions]] <- lapply(data[numericVars[numericVars %in% timeOptions]],as.POSIXct,format = "%Y-%m-%d %H:%M:%S")
  
  
  for (value in intersect(numericVars,timeOptions)){
    data <- lkpToMiddleTime(data,year=year,timeVar = value)
  }
  
  data[numericVars[numericVars %in% numericOptions]] <- lapply(data[numericVars[numericVars %in% numericOptions]],as.numeric)
  
  for (value in catVars){
    data <- factorLkp(data,year=year,catVar = value)
  }
  
  return(data)
}
```

```{r}
#state17 <- retrieveCensus(year=2022,numericVars=c("AGEP","PWGTP","JWDP"),catVars=c("FER","SEX"),geographyLevel = "State",geographySpec = 17)

#state17
```

## Function to pass multiple years and retrieve data

```{r}
retrieveMultiYearCensus <- function(years=c(2022),numericVars=c("AGEP","PWGTP"),catVars=c("SEX"),geographyLevel =c("All"),geographySpec = NULL) {
  combinedTibble <- retrieveCensus(year=years[1],numericVars=numericVars,catVars=catVars,geographyLevel=geographyLevel,geographySpec = geographySpec)
  combinedTibble$year <- years[1]
  for (i in 2:length(years)) {
    yearTibble <- retrieveCensus(year=years[i],numericVars=numericVars,catVars=catVars,geographyLevel=geographyLevel,geographySpec = geographySpec)
    yearTibble$year <- years[i]
    combinedTibble <- dplyr::union(combinedTibble,yearTibble)
  }
  return(combinedTibble)
}
```

## Testing multi-year function

```{r}
#state17MultiYear <- retrieveMultiYearCensus(years=c(2021,2022),geographyLevel = "State",geographySpec = 17)

#state17MultiYear
```

### test "retrieveCensus" function

```{r}
censusData<-retrieveCensus(year=2022, numericVars=c("AGEP", "GASP", "PWGTP", "JWAP", "JWDP"), catVars = c("SEX", "HHL"),geographyLevel = "State",geographySpec = 17)
```

### Check "retrieveCensus" function output object structure

```{r}
#names(censusData)
#length(names(censusData))
#str(censusData)
#head(censusData)
#censusData
```

# Create custom summary function

### Notes to user: censusSummerizR function will calculate weighted sample mean and weighted sample standard deviations for the numeric variables of interest and will calculate counts of the categorical variables of interest.  You should select variables to evaluate that were pulled from the PUMS Census API using one of the "retrieveCensus" or "retrieveMultiYearCensus functions.  Variables not in your starting dataset will cause censusSummerizR to stop.

```{r}
censusSummerizR <- function(x, numericVars=c("AGEP","GASP","GRPIP","JWMNP","PWGTP"),   catVars=c("FER","HHL","HISPEED","JWTRNS","SCH","SCHL","SEX")){


#check user requested variables and create numeric and factor/character datasets to summarize seperately based on user choice of variables to explore

numericDataDefault <- x |>
  select(where(is.numeric))

charDataDefault <- x|>
  select(where(is.factor))

if(length(names(numericDataDefault))<length(numericVars)){
  stop("You cannot subset data that was not pulled from API, re-pull desired variables")
}

if(length(names(charDataDefault))<length(catVars)){
  stop("You cannot subset data that was not pulled from API, re-pull desired variables")
}


if(length(names(numericDataDefault))>length(numericVars)){
  numericData<- x |> 
    select(numericVars)
  } else {
  numericData<- numericDataDefault |>
    select(where(-"PWGTP"))
} 


if(length(names(charDataDefault$names))>length(catVars)){
  charData<- x |> 
    select(catVars)
  } else {
  charData<- charDataDefault 
}    

#create loop to mean each variable from numericData and place in list with name
splMean <- list()
for(i in 1:length(numericData)){
  splMean[[i]] <- as.numeric((sum(numericData[[i]] %*% censusData$PWGTP)/sum(censusData$PWGTP)))
  names(splMean)[i]<-paste(names(numericData[i]))
}

#create loop to calculate sample SD from numericData and place in list with name
splSD <- list()
for(i in 1:length(numericData)){
  splSD[[i]] <- (sqrt(sum(numericData[[i]]^2 %*% censusData$PWGTP)/sum(censusData$PWGTP)-splMean[[i]]^2))
  names(splSD)[i]<-paste(names(numericData[i]))
}

#coerce splMean and splSD to Tibbles
splMeanTbl<-as_tibble(splMean)
splSDTbl<-as_tibble(splSD)

#Create loop to generate counts for each categorical variable
catSummary <- list()
for(i in 1:length(charData)){
  catSummary[[i]]<- charData[i] |>
    group_by(charData[i]) |>
      summarize(n=n())
    names(catSummary)[i]<-paste("count", names(charData[i]), sep="_")
}

numSumRowNames <- as_tibble(c("splMean", "splSD"))
numericSum <- tibble()
numericSum <- as_tibble(bind_rows(splMeanTbl,splSDTbl))
numericSumNamed <- as_tibble(bind_cols(numSumRowNames,numericSum))

#Need to plate "numericSumNamed" in its own named list so that output is visually appealing, and each object is of similar dimensions.
meanSD <-list(numericSumNamed)
names(meanSD) <- "Mean and SD"


#Return liSt of numeric and categorical summaries
return(c(catSummary,meanSD))

}

```

## Test out censusSummerizR Function

```{r}
summaryList<-censusSummerizR(censusData, numericVars = c("AGEP", "GASP"), catVars = c( "SEX"))

#Present example data in rendered webpage
knitr::kable(summaryList[1])
knitr::kable(summaryList[2])
knitr::kable(summaryList[3])
```
