[
  {
    "objectID": "ST588Project1.html",
    "href": "ST588Project1.html",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "",
    "text": "In our Data Science for Statisticians course we have learning how to do the following:\n\nWork with Base R\nLeverage the tidyverse library to read, manipulate and analyze data\nBuild functions\nBuild API Calls\n\nUsing this (nonexhaustive) list of skills and more, we are going to explore person-level data within the Public Use Microdata Sample (PUMS) Census dataset. Throughout this document we will build functions to read, summarize and plot the data. We will provide a narrative that explains the code and the functionality."
  },
  {
    "objectID": "ST588Project1.html#project-introduction",
    "href": "ST588Project1.html#project-introduction",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "",
    "text": "In our Data Science for Statisticians course we have learning how to do the following:\n\nWork with Base R\nLeverage the tidyverse library to read, manipulate and analyze data\nBuild functions\nBuild API Calls\n\nUsing this (nonexhaustive) list of skills and more, we are going to explore person-level data within the Public Use Microdata Sample (PUMS) Census dataset. Throughout this document we will build functions to read, summarize and plot the data. We will provide a narrative that explains the code and the functionality."
  },
  {
    "objectID": "ST588Project1.html#install-packages",
    "href": "ST588Project1.html#install-packages",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Install Packages",
    "text": "Install Packages\nBefore getting into functions and technical details, it is important that the user have the appropriate packages installed and read into the session. Without these libraries the code will NOT run.\nNotes for user: You should load the packages in the below code chunk using install.packages() to load on your local machine.\n\nlibrary(\"tidyverse\")\nlibrary(\"censusapi\")\nlibrary(\"tidycensus\")\nlibrary(\"jsonlite\")\nlibrary(\"dplyr\")\nlibrary(\"lubridate\")\nlibrary(\"ggplot2\")"
  },
  {
    "objectID": "ST588Project1.html#basic-api-testing",
    "href": "ST588Project1.html#basic-api-testing",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Basic API Testing",
    "text": "Basic API Testing\nBefore building our API from scratch, lets use a specific API URL to ensure that we can retrieve data from the API, parse the data, and format as a tibble.\nBelow we are calling the GET function from the httr library to retrieve data from this API URL https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24. Feel free to copy and paste this into your web browser. You should see some data in your web browser.\nIn the below, the output is less friendly…\n\ncensusApiTest &lt;- httr::GET(paste('https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24'))\n\ncensusApiTest\n\nResponse [https://api.census.gov/data/2022/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24]\n  Date: 2024-10-04 05:12\n  Status: 200\n  Content-Type: application/json;charset=utf-8\n  Size: 938 kB\n[[\"SEX\",\"PWGTP\",\"MAR\",\"SCHL\"],\n[\"2\",\"6\",\"5\",\"24\"],\n[\"2\",\"23\",\"2\",\"24\"],\n[\"1\",\"23\",\"3\",\"24\"],\n[\"1\",\"80\",\"5\",\"24\"],\n[\"1\",\"16\",\"1\",\"24\"],\n[\"1\",\"107\",\"3\",\"24\"],\n[\"2\",\"10\",\"5\",\"24\"],\n[\"1\",\"22\",\"1\",\"24\"],\n[\"2\",\"127\",\"5\",\"24\"],\n...\n\n\nBelow, we are building a function that takes the raw data (the input) and returns a tibble as the output. We are using a combination of pre-built functions from our libraries to parse the raw data to JSON. The first row represents our column headers while the rest of the rows represent the data points.\nWe construct the tibble by passing the data points and using our headers to assign column names to the tibble.\nYou can see the output is much prettier (and easier to work with) than before!\n\nrawToTibble &lt;- function(rawData){\n  jsonData &lt;- fromJSON(rawToChar(rawData$content))\n  ## Extract column names\n  colNames &lt;- jsonData[1,]\n  \n  # Remove the first row from the data \n  jsonData &lt;- jsonData[-1,]\n  \n  tibbleData &lt;- as_tibble(jsonData)\n  colnames(tibbleData) &lt;- colNames\n  return(tibbleData)\n}\n\nrawToTibble(censusApiTest)\n\n# A tibble: 44,079 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 2     6     5     24   \n 2 2     23    2     24   \n 3 1     23    3     24   \n 4 1     80    5     24   \n 5 1     16    1     24   \n 6 1     107   3     24   \n 7 2     10    5     24   \n 8 1     22    1     24   \n 9 2     127   5     24   \n10 2     46    5     24   \n# ℹ 44,069 more rows"
  },
  {
    "objectID": "ST588Project1.html#some-helper-functions-for-querying-the-api",
    "href": "ST588Project1.html#some-helper-functions-for-querying-the-api",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Some Helper Functions for Querying the API",
    "text": "Some Helper Functions for Querying the API\nOur functions used the build and query APIs rely on a series of other functions. These other functions were built to segment complex problems into modules, reduce duplicate code and improve readability for technical users.\nBrief explanations fo each helper function:\n\ncheckVarsValid - Our function used to query the API can only accept certain variables. This function ensures the variables passed by the user (vars) are all in the list of valid variables (validVars). If not, the function will stop and tell the user that they have provided an invalid variable(s).\nvarsLkpTibble - Sometimes our variables require that the user lookup those variables and fetch a different attribute from that lookup. These values can vary year to year, so the user must pass the year, the name of the variable and a column name for the lookup value (just “lkpVal” by default). A tibble is returned.\nmidTimeFunc - Some variables represent an interval of time. We want to return the midpoint of that interval, but the raw data type is not user friendly. This function takes start and ends of the interval in the format “3:29 p.m.” and transforms into HMS format\nlkpToMiddleTime - This helper function leverages our two (2) previous helper functions to lookup time intervals in the string format “3:29 p.m. to 3:33 p.m”, retrieve the median in the interval, cast as HMS format and return the transformed tibble.\nfactorLkp - When given categorical variables as integers (1,2,3…etc) we want to return meaningful character values. We again use our helper function varsLkpTibble to lookup the values for a specific year. Using the factor() function, we pass our original data points, an ordered list of integers as our levels and the paired character values as our labels. This is also applied directly to a tibble\n\n\ncheckVarsValid &lt;- function(vars,validVars){\n    if (!all(vars %in% validVars)) {\n    stop(\"Invalid variables: \", paste(vars[!vars %in% validVars], collapse = \", \"))\n  }\n}\n\nvarsLkpTibble &lt;- function(year,varName,lkpVal=\"lkpVal\"){\n  rawData &lt;- httr::GET(url=paste0('https://api.census.gov/data/',year,'/acs/acs1/pums/variables/',varName,'.json'))\n  jsonData &lt;- fromJSON(rawToChar(rawData$content))\n  tibbleData &lt;- as_tibble(jsonData$values$item)\n  tibbleData &lt;- tibbleData %&gt;%\n    pivot_longer(cols=names(tibbleData),\n                 names_to = varName,\n                 values_to = lkpVal\n                 )\n  return(tibbleData)\n}\n\nmidTimeFunc &lt;- function(startTime,endTime){\n  midAddlSecs &lt;- as.numeric(difftime(endTime,startTime,units=\"secs\"))/2\n  midTotalSecs &lt;- as.numeric(startTime) + midAddlSecs\n  midhours &lt;- floor(midTotalSecs/(60*60))\n  midminutes &lt;- floor((midTotalSecs-(60*60*midhours))/60)\n  midseconds &lt;- floor((midTotalSecs-(60*60*midhours)-60*midminutes)/60)\n  timeString &lt;- paste(midhours,midminutes,midseconds,sep=\":\")\n  hmsTime &lt;- hms::parse_hms(timeString)\n  return(timeString)\n}\n\nlkpToMiddleTime &lt;- function(tibble,year=2022,timeVar){\n  apiData &lt;- varsLkpTibble(year=year,varName = timeVar,lkpVal = \"TIME_INTERVAL\")\n  intervalTibble &lt;- inner_join(tibble,apiData)\n  returnData &lt;- intervalTibble %&gt;%\n    select(-c(timeVar)) %&gt;%\n    mutate(TIME_INTERVAL = ifelse(TIME_INTERVAL == \"N/A (not a worker; worker who worked from home)\", NA, TIME_INTERVAL))\n  names(returnData) &lt;- c(names(returnData)[1:(length(names(returnData))-1)],timeVar)\n  returnData &lt;- returnData %&gt;%\n    separate_wider_delim(timeVar,delim = \" to \",names=c('StartTime','EndTime'),too_few=c('align_start')) %&gt;%\n    mutate(StartTime = parse_time(gsub(\"\\\\.\", \"\", StartTime),format = \"%I:%M %p\"),\n           EndTime = parse_time(gsub(\"\\\\.\", \"\", EndTime),format = \"%I:%M %p\"),\n           MidTime = ifelse(!is.na(StartTime), midTimeFunc(StartTime,EndTime),NA)\n           )\n  returnData[[timeVar]] &lt;- hms::as_hms(returnData$MidTime)\n  returnData &lt;- returnData %&gt;%\n    select(-c('StartTime','EndTime','MidTime'))\n  return(returnData)\n}\n\nfactorLkp &lt;- function(tibbleData,year,catVar){\n  apiData &lt;- varsLkpTibble(year=year,varName = catVar)\n  x &lt;- tibbleData[[catVar]]\n  levels &lt;- sort(as.numeric(unique(x)))\n  apiData[[catVar]] &lt;- as.numeric(apiData[[catVar]])\n  apiData &lt;- apiData %&gt;%\n    filter(get(catVar) %in% levels) %&gt;%\n    arrange(get(catVar))\n  labels &lt;- apiData$lkpVal\n  newVec &lt;- factor(x=x,levels=levels,labels = labels)\n  tibbleData[[catVar]] &lt;- newVec\n  return(tibbleData)\n}"
  },
  {
    "objectID": "ST588Project1.html#querying-the-api",
    "href": "ST588Project1.html#querying-the-api",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Querying the API",
    "text": "Querying the API\nFinally, we are building our function to query the API.\n\nInputs/Parameters\nThe user will pass the year (default = 2022), a vector of numeric variables (default = “AGEP”,“PWGTP”), a vector of categorical variables (default = “SEX”), a geography level (default = “ALL”). Optionally, the user can also pass the specific identifier for that geography level if they choose.\n\n\nParameter Validation\nThe first part of the function validates that parameters meet certain criteria. That criteria is as follows:\n\nOnly one year value should be passed in the parameter\nThe year parameter value should be between 2010 & 2022\nNumeric variables, categorical variables and the geography level had to be valid variables in a pre-approved list\nOne numeric variables other than PWGTP had to be passed in the numericVars parameter.\nOne categorical variable must be passed in the catVars parameter\n\nIf these criteria are not met, a detailed stop() message is returned by the function\n\n\nUsing Parameters to Construct API\nTo construct the API URL, we need the constant components (base), the year, a list of variables and the geography specification. Year is directly passed by the user with no transformations. We create our variables list by unioning the numericVars and catVars parameter values and delimiting with a comma (,).\nFor the geography specification, we use switch() and if else functions to follow these generic rules:\n\nIf the user passes “All” in geographyLevel, return an empty string\nIf the user passes another value in geography level return in the following format “geographyLevel:geographySpec”. An example is “state:17”\nIf the user passes another value in geography level and does NOT include a geography spec, return everything for that level in the format (example) of “state:*”, with an asterik representing all.\n\nPaste all of these string values together to construct the API and use httr:get() and our helpfer function the return a tibble called “data”\n\n\nPost API Transformations\nAll of the values in the tibble are “character” data type and our category variable values are keys.\nTo make this more usable we are….\n\nConverting our numeric variables to “numeric” type\nLooking up time values for our time variables and returning the median time in the provided interval in HMS format\nLookup up categorical values and apply our factor function.\n\n\nretrieveCensus &lt;- function(year=2022,numericVars=c(\"AGEP\",\"PWGTP\"),catVars=c(\"SEX\"),geographyLevel =c(\"All\"),geographySpec = NULL){\n  # Check if year is a single value AND the value passed is between 2010 and 2022\n  \n  if (length(year)!=1){\n    stop(\"A single year must be passed\")\n  }\n  \n  if (year &lt; 2010 | year &gt; 2022){\n    stop(\"The year passed must be between 2010 & 2022\")\n  }\n  \n  # Check if values passed in the numericVars (catVars) are within the numericOptions (catOptions) vector(s)\n  \n  numericReq &lt;- \"PWGTP\"\n  \n  numericOptions &lt;- c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\",\"PWGTP\")\n  timeOptions &lt;- c(\"JWAP\",\"JWDP\")\n  \n  numericTimeOptions &lt;- c(numericOptions,timeOptions)\n  \n  checkVarsValid(var=numericVars,validVars = numericTimeOptions)\n  \n  catOptions &lt;- c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\")\n  \n  checkVarsValid(vars=catVars, validVars = catOptions)\n  \n  geographyOptions &lt;- c(\"All\",\"Region\",\"Division\",\"State\")\n  \n  checkVarsValid(vars=geographyLevel, validVars = geographyOptions)\n  \n  ## If PWGTP not in the numericVars parameter, add it\n  \n  if (numericReq %in% numericVars) {\n    numericVars &lt;- numericVars\n  } else {\n    numericVars &lt;- c(numericVars,numericReq)\n  }\n  \n  ## Check to make sure the number of numeric variables that will be returned is NOT &lt; 2. The number of categorical variables should not be &lt; 1\n  \n  if (length(numericVars) &lt; 2) {\n    stop(\"One numeric variable other than \", paste(numericReq),\" must be given in the numericVars parameter\")\n  }\n  \n  if (length(catVars) &lt; 1) {\n    stop(\"One categorical variable must be given to be returned\")\n  }\n  \n ## If all variables are of valid length and valid values, paste them together to be passed in the API call\n  \n  regioninPrefix &lt;- switch(\n    geographyLevel,\n    All = \"\",\n    Division = \"division\",\n    Region = \"region\",\n    State = \"state\"\n  )\n  regioninSuffix &lt;- ifelse(is.null(geographySpec),\"*\",geographySpec)\n  \n  regioninString &lt;- if(regioninPrefix!=\"\"){paste0('&for=',regioninPrefix,\":\",regioninSuffix)}\n  \n  allVarsReq &lt;- c(numericVars,catVars)\n  varString &lt;- NULL\n  \n  for (value in allVarsReq){\n    varString &lt;- paste0(varString,value,if(value != allVarsReq[length(allVarsReq)]){\",\"})\n  }\n  \n  ## Build API, fetch data, convert to tibble\n  \n  apiURL &lt;- paste0('https://api.census.gov/data/',year,'/acs/acs1/pums?get=',varString,regioninString)\n  \n  rawData &lt;- httr::GET(apiURL)\n  \n  data &lt;- rawToTibble(rawData)\n  \n  ## Change data types\n  \n  for (value in intersect(numericVars,timeOptions)){\n    data &lt;- lkpToMiddleTime(data,year=year,timeVar = value)\n  }\n  \n  data[numericVars[numericVars %in% numericOptions]] &lt;- lapply(data[numericVars[numericVars %in% numericOptions]],as.numeric)\n  \n  for (value in catVars){\n    data &lt;- factorLkp(data,year=year,catVar = value)\n  }\n  \n  return(data)\n}"
  },
  {
    "objectID": "ST588Project1.html#using-our-api-function",
    "href": "ST588Project1.html#using-our-api-function",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Using our API Function",
    "text": "Using our API Function\nLets show an example of how our API call works (and that it works). For a state (code 17), we want to retrieve AGEP,PWGTP,JWDP,FER and SEX variables from the 2022 PUMS data set.\nAGEP,PWGTP are numeric. JWDP is time value. FER and SEX are categorical\nWe see in the output the rules defined in the previous section have been followed.\n\nstate17 &lt;- retrieveCensus(year=2021,numericVars=c(\"AGEP\",\"PWGTP\",\"JWDP\"),catVars=c(\"FER\",\"SEX\",\"SCHL\"),geographyLevel = \"State\",geographySpec = 17)\n\nstate17\n\n# A tibble: 85,053 × 7\n    AGEP PWGTP FER                                       SEX   SCHL  state JWDP \n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;                                     &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; &lt;tim&gt;\n 1    37   104 N/A (less than 15 years/greater than 50 … Male  Grad… 17       NA\n 2    48    29 No                                        Fema… Regu… 17       NA\n 3    66    19 N/A (less than 15 years/greater than 50 … Fema… Mast… 17       NA\n 4    51    84 N/A (less than 15 years/greater than 50 … Male  No s… 17       NA\n 5    86     4 N/A (less than 15 years/greater than 50 … Male  1 or… 17       NA\n 6    32    86 N/A (less than 15 years/greater than 50 … Male  GED … 17       NA\n 7    61    30 N/A (less than 15 years/greater than 50 … Fema… Regu… 17       NA\n 8    50    38 No                                        Fema… Regu… 17       NA\n 9    74     6 N/A (less than 15 years/greater than 50 … Fema… Grad… 17       NA\n10    36     8 N/A (less than 15 years/greater than 50 … Male  Regu… 17       NA\n# ℹ 85,043 more rows"
  },
  {
    "objectID": "ST588Project1.html#what-if-i-want-multiple-years-of-data",
    "href": "ST588Project1.html#what-if-i-want-multiple-years-of-data",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "What if I want multiple years of data?",
    "text": "What if I want multiple years of data?\nFor multiple years of data, we have to make a separate API call and data processes for EACH year and union these datasets together in one tibble.\nOur function takes in the same parameters as our previous function for single year. This is because we are iterating through each value in our year vector, grabbing the same variables form that years API and then appending.\nTo know what year the data came from, we append the “year” to the unioned tibble.\n\nretrieveMultiYearCensus &lt;- function(years=c(2022),numericVars=c(\"AGEP\",\"PWGTP\"),catVars=c(\"SEX\"),geographyLevel =c(\"All\"),geographySpec = NULL) {\n  combinedTibble &lt;- retrieveCensus(year=years[1],numericVars=numericVars,catVars=catVars,geographyLevel=geographyLevel,geographySpec = geographySpec)\n  combinedTibble$year &lt;- years[1]\n  for (i in 2:length(years)) {\n    yearTibble &lt;- retrieveCensus(year=years[i],numericVars=numericVars,catVars=catVars,geographyLevel=geographyLevel,geographySpec = geographySpec)\n    yearTibble$year &lt;- years[i]\n    combinedTibble &lt;- dplyr::union(combinedTibble,yearTibble)\n  }\n  return(combinedTibble)\n}"
  },
  {
    "objectID": "ST588Project1.html#using-our-multi-year-function",
    "href": "ST588Project1.html#using-our-multi-year-function",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Using our multi-year function",
    "text": "Using our multi-year function\nAgain, this is the same function so the arguments for retrieveMultiYearCensus are almost identical to retrieveCensus. The only difference is retrieveMultiYearCensus accepts a multi-value vector of years.\nLets test this on years 2021 and 2022 with a state (code 17). We will return our default parameters.\n\nstate17MultiYear &lt;- retrieveMultiYearCensus(years=c(2021,2022),geographyLevel = \"State\",geographySpec = 17)\n\nstate17MultiYear\n\n# A tibble: 81,469 × 5\n    AGEP PWGTP SEX    state  year\n   &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;chr&gt; &lt;dbl&gt;\n 1    37   104 Male   17     2021\n 2    48    29 Female 17     2021\n 3    66    19 Female 17     2021\n 4    51    84 Male   17     2021\n 5    86     4 Male   17     2021\n 6    32    86 Male   17     2021\n 7    61    30 Female 17     2021\n 8    50    38 Female 17     2021\n 9    74     6 Female 17     2021\n10    36     8 Male   17     2021\n# ℹ 81,459 more rows"
  },
  {
    "objectID": "ST588Project1.html#test-retrievecensus-function",
    "href": "ST588Project1.html#test-retrievecensus-function",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Test retrieveCensus function",
    "text": "Test retrieveCensus function\nThis test dataset is intended to test that data called from the API using the retrieveCensus function will be usable by the censusSummerizR function below.\n\nnumeric and categorical variables were selected psuedo-randomly to test function.\nextracted data were placed into censusData object.\n\n\ncensusData&lt;-retrieveCensus(year=2022, numericVars=c(\"AGEP\", \"GASP\", \"PWGTP\", \"JWAP\", \"JWDP\"), catVars = c(\"SEX\", \"HHL\"),geographyLevel = \"State\", geographySpec = 17)\n\n\nCheck retrieveCensus function output object structure.\nThe code chunk below can be used to visualize the structure of the data extracted by the retrieveCensus function. These visualizations can be helpful to understand the types of data presented (in truncated form), some representative values, and help the developer think of ways these data can be manipulated during creation of downstream functions. names shows the column names, length() give us a number of items in the object, str() tells us the stucture of the object, and calling censusData shows us the first 1000 rows of the object. This code has been commented out as the output takes up a lot of space!\n\n#names(censusData)\n#length(names(censusData))\n#str(censusData)\n#head(censusData)\n#censusData"
  },
  {
    "objectID": "ST588Project1.html#test-out-censussummerizr-function",
    "href": "ST588Project1.html#test-out-censussummerizr-function",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Test out censusSummerizR Function",
    "text": "Test out censusSummerizR Function\nNow that the censusSummerizR function has been written, we need to make sure that it works as intended. The variables below are representative numeric and categorical variables and return summaries, exclusive of the “weight” variable, PWGTP. A list of tibbles that describe the sample mean, sample SD and counts is returned.\n\nsummaryList&lt;-censusSummerizR(censusData, numericVars = c(\"AGEP\", \"GASP\"), catVars = c( \"SEX\"))\nsummaryList\n\n$count_SEX\n# A tibble: 2 × 2\n  SEX        n\n  &lt;fct&gt;  &lt;int&gt;\n1 Male   38888\n2 Female 43699\n\n$count_HHL\n# A tibble: 6 × 2\n  HHL                                    n\n  &lt;fct&gt;                              &lt;int&gt;\n1 N/A (GQ/vacant)                     4681\n2 English Only                       60302\n3 Spanish                             8908\n4 Other Indo-European languages       4886\n5 Asian and Pacific Island languages  2833\n6 Other Language                       977\n\n$`Mean and SD`\n# A tibble: 2 × 3\n  value    AGEP  GASP\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 splMean  38.0  115.\n2 splSD    26.9  199.\n\n#Present example data in rendered webpage in nicely formatted tables\nknitr::kable(summaryList[1])\n\n\n\n\n\n\n\n\nSEX\nn\n\n\n\n\nMale\n38888\n\n\nFemale\n43699\n\n\n\n\n\n\n\n\nknitr::kable(summaryList[2])\n\n\n\n\n\n\n\n\nHHL\nn\n\n\n\n\nN/A (GQ/vacant)\n4681\n\n\nEnglish Only\n60302\n\n\nSpanish\n8908\n\n\nOther Indo-European languages\n4886\n\n\nAsian and Pacific Island languages\n2833\n\n\nOther Language\n977\n\n\n\n\n\n\n\n\nknitr::kable(summaryList[3])\n\n\n\n\n\n\n\n\nvalue\nAGEP\nGASP\n\n\n\n\nsplMean\n37.97134\n115.0748\n\n\nsplSD\n26.87618\n198.8157"
  },
  {
    "objectID": "ST588Project1.html#generate-function-to-plot-output-retrieved-from-pums-census-api",
    "href": "ST588Project1.html#generate-function-to-plot-output-retrieved-from-pums-census-api",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Generate function to plot output retrieved from PUMS Census API",
    "text": "Generate function to plot output retrieved from PUMS Census API\nThe function censusPlotR will generate box plots for character variables that are returned as categorical from retrieveCensus. This can help the user visualize differences and similarities between categories.\n\ncensusPlotR &lt;- function(x, catVars=c(\"FER\",\"HHL\",\"HISPEED\",\"JWTRNS\",\"SCH\",\"SCHL\",\"SEX\"), numericVars=c(\"AGEP\",\"GASP\",\"GRPIP\",\"JWMNP\")){\n\n#force user to specify a single numeric and single categorical variable\nif(length(numericVars)&gt;1){\n  stop(\"You cannot plot more than 1 numeric variable\")\n}\n\nif(length(catVars)&gt;1){\n  stop(\"You cannot plot more than 1 categorical variable\")\n}\n\n#plot function weightss numeric variable by PWGTP.  Recommended \"weight=\" as an aesthetic did not seem to work and may be a known issue. \nggplot(x, aes(x = get(catVars), y = get(numericVars)*PWGTP)) +\n         geom_boxplot() +\n         ggtitle(\"Boxplot of User Selected Categorical Variables Weighted by PWGTP\") +\n  xlab(catVars) + ylab(numericVars)\n\n}"
  },
  {
    "objectID": "ST588Project1.html#test-plot-function",
    "href": "ST588Project1.html#test-plot-function",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Test Plot Function",
    "text": "Test Plot Function\nHere we test the censusPlotR function by plotting AGEP by SEX.\n*Notes to User: enter dataset to evaluate in function and enter a single categorical variable and a single numeric variable. The funtion will stop and return the errors: \"You cannot plot more than 1 numeric variable\" and/or \"You cannot plot more than 1 categorical variable\" if more than 1 of either variable type is requested.\n\nsummaryPlot &lt;- censusPlotR(censusData, catVars= \"SEX\", numericVars = \"AGEP\")\n\nsummaryPlot"
  },
  {
    "objectID": "ST588Project1.html#using-it-all-together",
    "href": "ST588Project1.html#using-it-all-together",
    "title": "ST588 Project 1\nMatt Bray\nTyler Hunt",
    "section": "Using it all together",
    "text": "Using it all together\nWe’ve built and tested these functions, but lets use them all together.\nI want to explore data from a state (key = 17). I want AGEP, GASP, JWMNP, SEX, HHL, SCH and SCHL variables returned. I want the data for this state from 2020-2022.\nA list of variables and there definitions can be found here https://api.census.gov/data/2022/acs/acs1/pums/variables.html\nLets call our retrieveMultiYearCensus function and pass the appropriate parameters\ncensusStateData &lt;- retrieveMultiYearCensus(years=c(2021,2022),numericVars = c(“AGEP”,“GASP”,“JWMNP”),catVars=c(“HHL”,“SCH”,“SCHL”,“SEX”),geographyLevel = “State”,geographySpec = 17)\ncensusStateData"
  }
]